# 项目评估前端缓存方案设计（简化版）

**版本**：V2.0 - 简化版  
**更新日期**：2024-12-22  
**核心原则**：不自动加载，用户主动控制，简单可靠

---

## 一、核心原则

1. **不自动加载**：新建评估永远是空白表单，不查询也不恢复任何缓存数据
2. **用户主动恢复**：只有当用户点击"加载草稿"时，才主动查询并恢复缓存
3. **关键操作强保存**：步骤切换、页面卸载等操作立即保存，不受debounce影响
4. **简单交互**：只保留"保存草稿"和"加载草稿"两个手动操作
5. **数据隔离**：后端数据（重新评估）和缓存数据永不混合

---

## 二、进入场景划分

| 进入方式 | 数据来源 | 是否加载缓存 | Session策略 | 说明 |
|---------|---------|-------------|------------|------|
| **新建评估**<br/>`/assessment/new` | 空白表单 | ❌ 不加载 | 生成新sessionId | 全新开始，只自动保存到当前会话 |
| **重新评估**<br/>`/assessment/new?template_id=xxx` | 后端接口 | ❌ 不加载 | 生成新sessionId | 后端数据优先，即使字段缺失也不补全 |
| **加载草稿**<br/>`/assessment/new?session=xxx` | IndexedDB | ✅ 加载指定session | 使用URL中的sessionId | 在新标签页打开，避免污染原数据 |

---

## 三、数据模型（极简）

```typescript
// IndexedDB主表：assessment_cache
interface AssessmentCacheRecord {
  id: string;                    // UUID主键
  sessionId: string;            // 会话ID（唯一标识一次评估）
  currentStep: number;          // 当前步骤（0-3）
  
  // 核心数据（只保存用户填写的值，不保存配置）
  data: {
    // 风险评估
    risk_scores: Record<string, number>;
    ai_unmatched_risks: Array<{description: string, score: number}>;
    custom_risk_items: Array<{description: string, score: number}>;
    
    // 工作量
    development_workload: API.WorkloadRecord[];
    integration_workload: API.WorkloadRecord[];
    
    // 其他成本
    travel_months: number;
    travel_headcount: number;
    maintenance_months: number;
    maintenance_headcount: number;
    maintenance_daily_cost: number;
    risk_cost_items: Array<{description: string, cost: number}>;
    
    // 表单字段值（antd Form）
    formValues: Record<string, any>;
  };
  
  metadata: {
    updatedAt: number;          // 最后更新时间
    isManualSave: boolean;      // true=手动保存, false=自动保存
    projectName?: string;       // 手动保存时的项目名称（可选）
  };
}
```

**重要：不保存`configData`，每次恢复后强制使用最新配置**

---

## 四、分层保存策略

### 4.1 保存触发层级

```
┌─────────────────────────────────────────────────────┐
│  Tier 1: 关键操作 - 立即保存 (deboounce=0)          │
├─────────────────────────────────────────────────────┤
│  • 步骤切换（点击"上一步"/"下一步"）               │
│  • 页面卸载（beforeunload事件）                     │
│  • 页面隐藏（visibilitychange事件）                │
│  • 手动点击"保存草稿"按钮                          │
└─────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────┐
│  Tier 2: 表单变更 - debounce 3000ms                │
├─────────────────────────────────────────────────────┤
│  • 任意表单字段值变更                               │
│  • 动态表单项增删（工作量模块）                     │
│  • AI评估结果应用                                   │
└─────────────────────────────────────────────────────┘
```

### 4.2 实现代码

```typescript
// utils/assessmentCache.ts
class AssessmentCacheManager {
  private db: Dexie;
  private sessionId: string;
  private debounceTimer: NodeJS.Timeout | null = null;
  
  constructor() {
    this.db = new Dexie('AssessmentDB');
    this.db.version(1).stores({
      cache: 'id, sessionId, metadata.updatedAt'
    });
    this.sessionId = this.generateSessionId();
  }
  
  private generateSessionId(): string {
    return `sess_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
  }
  
  // 立即保存（关键操作）
  async saveImmediate(data: any, step: number, isManualSave = false): Promise<void> {
    // 清除debounce计时器
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }
    
    const record = {
      id: crypto.randomUUID(),
      sessionId: this.sessionId,
      currentStep: step,
      data,
      metadata: {
        updatedAt: Date.now(),
        isManualSave
      }
    };
    
    await this.db.cache.put(record);
  }
  
  // debounce保存（表单变更）
  saveDebounced(data: any, step: number): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    
    this.debounceTimer = setTimeout(async () => {
      await this.saveImmediate(data, step, false);
      this.debounceTimer = null;
    }, 3000);
  }
  
  // 加载指定session
  async loadSession(sessionId: string): Promise<AssessmentCacheRecord | null> {
    const record = await this.db.cache
      .where('sessionId')
      .equals(sessionId)
      .orderBy('metadata.updatedAt')
      .last(); // 取最新的
  
    return record || null;
  }
  
  // 获取历史版本列表（手动保存优先）
  async getHistory(): Promise<AssessmentCacheRecord[]> {
    return this.db.cache
      .orderBy('metadata.updatedAt')
      .reverse()
      .filter(record => record.metadata.isManualSave)
      .limit(20)
      .toArray();
  }
  
  // 清理过期数据（保留最近7天的自动保存）
  async cleanup(): Promise<number> {
    const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    return this.db.cache
      .where('metadata.updatedAt')
      .below(sevenDaysAgo)
      .and(record => !record.metadata.isManualSave)
      .delete();
  }
}

// 单例
export const assessmentCache = new AssessmentCacheManager();
```

---

## 五、React组件集成

```typescript
// pages/Assessment/New.tsx
const NewAssessmentPage: React.FC = () => {
  const [form] = Form.useForm();
  const [searchParams] = useSearchParams();
  const [current, setCurrent] = useState(0);
  const [assessmentData, setAssessmentData] = useState<API.AssessmentData>(EMPTY_ASSESSMENT);
  
  // 1. 初始化：根据进入场景决定数据
  useEffect(() => {
    const initialize = async () => {
      // 场景A：URL带session参数 - 恢复指定会话
      const sessionFromURL = searchParams.get('session');
      if (sessionFromURL) {
        const record = await assessmentCache.loadSession(sessionFromURL);
        if (record) {
          setAssessmentData(record.data);
          setCurrent(record.currentStep);
          form.setFieldsValue(record.data.formValues);
          message.info(`已恢复草稿（${formatTime(record.metadata.updatedAt)}）`);
          return;
        }
      }
      
      // 场景B：重新评估 - 加载后端数据
      const templateId = searchParams.get('template_id');
      if (templateId) {
        const result = await getProjectDetail(templateId);
        const backendData = parseBackendData(result);
        setAssessmentData(backendData);
        form.setFieldsValue(backendData);
        // 生成新的sessionId（不与缓存数据混淆）
        assessmentCache.generateNewSession();
        return;
      }
      
      // 场景C：全新创建 - 空白表单
      // 什么都不做，使用EMPTY_ASSESSMENT
      form.resetFields();
      assessmentCache.generateNewSession();
    };
    
    initialize();
  }, []);
  
  // 2. 表单变更 - debounce自动保存
  useEffect(() => {
    assessmentCache.saveDebounced(assessmentData, current);
  }, [assessmentData, current]);
  
  // 3. 步骤切换 - 立即保存
  const handleStepChange = async (nextStep: number) => {
    await assessmentCache.saveImmediate(assessmentData, nextStep, false);
    setCurrent(nextStep);
  };
  
  // 4. 手动保存 - 立即保存（带项目名称）
  const handleManualSave = async () => {
    const { name } = await Modal.info({
      title: '保存草稿',
      content: <Input placeholder="请输入草稿名称（可选）" />,
    });
    
    await assessmentCache.saveImmediate(assessmentData, current, true);
    message.success('草稿已保存');
  };
  
  // 5. 加载草稿 - 用户主动触发
  const handleLoadDraft = async () => {
    const history = await assessmentCache.getHistory();
    const selected = await showDraftSelector(history);
    
    if (selected) {
      // 在新标签页打开，避免污染当前数据
      window.open(`/assessment/new?session=${selected.sessionId}`, '_blank');
    }
  };
  
  // 6. 页面卸载 - 立即保存
  useEffect(() => {
    const beforeUnload = () => {
      assessmentCache.saveImmediate(assessmentData, current, false);
    };
    window.addEventListener('beforeunload', beforeUnload);
    return () => window.removeEventListener('beforeunload', beforeUnload);
  }, [assessmentData, current]);
  
  // 顶部按钮
  const ExtraButtons = (
    <Space>
      <Button onClick={handleManualSave}>保存草稿 ✓</Button>
      <Button onClick={handleLoadDraft}>加载草稿</Button>
    </Space>
  );
  
  return (
    <PageContainer extra={ExtraButtons}>
      {/* 步骤条和内容 */}
    </PageContainer>
  );
};
```

---

## 六、用户交互流程

### 6.1 新建评估

```mermaid
graph TD
    A[菜单：新建评估] --> B[进入 /assessment/new]
    B --> C[URL无session参数?]
    C -->|是| D[生成新sessionId]
    D --> E[加载空白表单]
    E --> F[用户填写]
    F --> G[每3秒自动保存（后台）]
    F --> H[点击"下一步"]
    H --> I[立即保存，切换步骤]
```

### 6.2 重新评估

```mermaid
graph TD
    A[历史项目点击"重新评估"] --> B[打开 /assessment/new?template_id=123]
    B --> C[调用 getProjectDetail()]
    C --> D[解析后端数据]
    D --> E[生成新sessionId（与旧数据隔离）]
    E --> F[加载后端数据（即使不完整）]
    F --> G[绝不查询IndexedDB补全数据]
```

### 6.3 加载草稿

```mermaid
graph TD
    A[点击"加载草稿"] --> B[查询历史版本列表]
    B --> C[弹窗显示手动保存的草稿]
    C --> D[用户选择一个草稿]
    D --> E[在新标签页打开 /assessment/new?session=xxx]
    E --> F[根据sessionId加载 IndexedDB 数据]
    F --> G[强制使用最新配置，数据恢复完成]
```

---

## 七、边界情况处理

### 7.1 快速填写后马上刷新（场景3）

```typescript
// 快速填写字段 → 0.5秒后点击刷新
// scenario: 用户输入数据后立即刷新

// 处理：
// 1. 表单输入触发 saveDebounced(data, 3000ms)
// 2. 用户在2秒内点击刷新
// 3. beforeunload 触发 saveImmediate(data, isAutoSave=true)
// 4. 数据立即保存，不丢失 ✅

// 代码实现：
window.addEventListener('beforeunload', () => {
  // 即使有debounce计时器，也立即执行保存
  assessmentCache.saveImmediate(assessmentData, current, false);
});
```

### 7.2 配置变更后恢复旧数据

```typescript
// 风险项配置已修改（如评分选项从1-5改为1-10）
// 恢复2天前的缓存数据

// 处理：
// 1. 恢复时不使用缓存的configData
// 2. 强制使用最新配置加载表单
// 3. 对于不匹配的数据：
//    - 如果旧数据评分超出新范围，重置为默认值
//    - 新增的风险项显示为空
//    - 删除的风险项忽略

// 代码实现：
const restoreData = (cachedData, freshConfig) => {
  // 只恢复用户填写的值
  const {risk_scores} = cachedData.data;
  
  // 使用最新配置渲染表单
  return freshConfig.risk_items.map(item => {
    const oldValue = risk_scores[item.item_name];
    
    // 验证旧值是否在新选项范围内
    const options = parseRiskOptions(item.options_json);
    const isValid = options.some(opt => opt.value === oldValue);
    
    return {
      item_name: item.item_name,
      value: isValid ? oldValue : undefined // 无效则置空
    };
  });
};
```

### 7.3 缓存数据损坏或解析失败

```typescript
// IndexedDB数据损坏或JSON解析失败

// 处理：
// 1. 捕获异常
// 2. 自动清理损坏的记录
// 3. 提示用户并降级到空白表单

// 代码实现：
try {
  const record = await assessmentCache.loadSession(sessionId);
  setAssessmentData(JSON.parse(record.data));
} catch (error) {
  console.error('缓存数据损坏:', error);
  message.error('草稿数据已损坏，将以空白表单开始');
  await assessmentCache.delete(sessionId); // 清理损坏数据
  setAssessmentData(EMPTY_ASSESSMENT);
}
```

---

## 八、数据一致性校验（新增功能）

### 8.1 需求说明

在第四步"生成总览"点击"保存项目"按钮时，对比：
- **JS内存中的当前数据**（`assessmentData`）
- **IndexedDB中的缓存数据**（最后一次保存）

**目的**：确保最终保存的是最新数据，防止因debounce延迟导致的数据丢失。

### 8.2 校验流程

```mermaid
graph TD
    A[点击"保存项目"] --> B{IndexedDB<br/>有缓存?}
    B -->|yes| C[对比JS数据 vs 缓存]
    B -->|no| J[直接保存到后端]
    
    C --> D{数据一致?}
    D -->|yes| J
    D -->|no| E[弹窗显示差异]
    
    E --> F{用户选择}
    F -->|重新保存草稿| G[立即saveImmediate()]
    G --> H[message.success('草稿已更新')]
    H --> I[return阻断保存]
    
    F -->|强制保存| J[saveProjectToBackend()]
    J --> K[message.success('项目已保存')]
    K --> L[删除当前session的缓存]
```

### 8.3 实现代码

```typescript
// 在 Overview.tsx 的保存按钮中添加校验
const Overview: React.FC<OverviewProps> = ({ assessmentData }) => {
  const handleSaveProject = async () => {
    // 1. 获取最新的IndexedDB缓存
    const cachedRecord = await assessmentCache.getLatest();
    
    // 2. 对比数据差异
    const diff = compareData(assessmentData, cachedRecord?.data);
    
    // 3. 如果有差异，阻断并提示
    if (diff.hasDifferences) {
      const action = await showDataMismatchModal(diff.details);
      
      if (action === 'resave') {
        // 用户选择"重新保存草稿"
        await assessmentCache.saveImmediate(assessmentData, 3, false);
        message.success('草稿已更新，请重新点击保存');
        return; // 阻断保存
      }
      
      if (action === 'force') {
        // 用户选择"强制保存"
        message.warning('正在使用当前数据保存，可能丢失部分变更');
        // 继续执行保存
      }
    }
    
    // 4. 数据一致，或用户选择强制保存
    await saveProjectToBackend(assessmentData);
  };
};

// 数据对比工具函数
interface DataDiff {
  hasDifferences: boolean;
  details: Array<{
    field: string;
    currentValue: any;
    cachedValue: any;
    type: 'added' | 'removed' | 'changed';
  }>;
}

function compareData(current: any, cached: any): DataDiff {
  const diff: DataDiff = {
    hasDifferences: false,
    details: []
  };
  
  if (!cached) {
    // 没有缓存（首次保存）
    return diff;
  }
  
  // 深度对比
  const currentJson = JSON.stringify(current);
  const cachedJson = JSON.stringify(cached);
  
  if (currentJson === cachedJson) {
    return diff; // 完全一致
  }
  
  diff.hasDifferences = true;
  
  // 详细对比关键字段
  const fieldsToCheck = [
    'risk_scores',
    'development_workload',
    'integration_workload',
    'travel_months',
    'maintenance_months',
    'risk_cost_items'
  ];
  
  fieldsToCheck.forEach(field => {
    const currentValue = JSON.stringify(current[field]);
    const cachedValue = JSON.stringify(cached[field]);
    
    if (currentValue !== cachedValue) {
      diff.details.push({
        field,
        currentValue: current[field],
        cachedValue: cached[field],
        type: cached[field] === undefined ? 'added' : 'changed'
      });
    }
  });
  
  return diff;
}

// 差异提示弹窗
const showDataMismatchModal = (diffDetails) => {
  return Modal.confirm({
    title: '检测到未保存的变更',
    icon: <ExclamationCircleOutlined />,
    width: 600,
    content: (
      <div>
        <p>当前页面数据与最后一次自动保存的草稿存在差异：</p>
        <ul style={{ maxHeight: 300, overflow: 'auto' }}>
          {diffDetails.map((item, idx) => (
            <li key={idx}>
              <strong>{getFieldLabel(item.field)}</strong>
              {item.type === 'added' 
                ? '：新增了数据'
                : item.type === 'changed' 
                  ? `：从 ${formatValue(item.cachedValue)} 变更为 ${formatValue(item.currentValue)}`
                  : '：删除了数据'}
            </li>
          ))}
        </ul>
        <p style={{ marginTop: 16, color: '#faad14' }}>
          建议：先点击"重新保存草稿"更新缓存，或选择"强制保存"使用当前数据
        </p>
      </div>
    ),
    okText: '重新保存草稿',
    cancelText: '强制保存',
    onOk: () => 'resave',
    onCancel: () => 'force'
  });
};
```

---

## 九、缓存清理策略

```typescript
// 后台定期清理（可选）
const CLEANUP_CONFIG = {
  // 自动保存保留7天
  autoSaveRetention: 7 * 24 * 60 * 60 * 1000,
  
  // 手动保存保留30天
  manualSaveRetention: 30 * 24 * 60 * 60 * 1000,
  
  // 每个session最多保留3个版本
  maxVersionsPerSession: 3,
  
  // 总大小超过100MB时清理
  maxTotalSize: 100 * 1024 * 1024,
};

// 在application启动时执行一次
useEffect(() => {
  assessmentCache.cleanup();
}, []);
```

---

## 十、技术问题解答

### Q1: 这个功能是否只涉及前端？

**答案：是的，几乎完全前端**

```typescript
// IndexedDB - 浏览器原生数据库，纯前端
const db = new Dexie('AssessmentDB');

// 所有操作都在浏览器完成
// - ✅ 不需要后端接口
// - ✅ 不需要数据库表
// - ✅ 不需要后端代码改动

// 只需要前端实现：
// 1. IndexedDB操作（Dexie.js封装）
// 2. React Hook集成
// 3. UI按钮和弹窗
```

**唯一与后端的交互**（但不需要改动）：
```typescript
// 场景：从历史项目"重新评估"
// 这个接口已经存在
const result = await getProjectDetail(templateId);

// 只是在前端拿到数据后，额外保存一份到IndexedDB
// 作为保险，不影响现有流程
```

---

## 十一、实施检查清单

### 核心功能
- [ ] 创建 `utils/assessmentCache.ts`（核心类）
- [ ] 创建 `hooks/useAssessmentCache.ts`（React集成）
- [ ] 创建 `types/cache.ts`（TypeScript类型）
- [ ] 修改 `pages/Assessment/New.tsx`（3个场景的进入判断）
- [ ] 修改 `pages/Assessment/components/Overview.tsx`（添加一致性校验）

### UI组件
- [ ] 添加顶部按钮"保存草稿"和"加载草稿"
- [ ] 实现 `LoadDraftModal`（历史版本选择弹窗）
- [ ] 实现 `DataMismatchModal`（数据不一致提示弹窗）

### 测试场景
- [ ] **场景1**：新建评估 → 填数据 → 刷新 → 不恢复 → 点击"加载草稿"可恢复
- [ ] **场景2**：重新评估 → 快速输入 → 切换步骤 → 数据不丢失
- [ ] **场景3**：新建评估 → 保存草稿 → 加载草稿 → 数据正确
- [ ] **场景4**：编辑数据 → 不等待debounce → 直接点"保存项目" → 弹窗提示差异
- [ ] **场景5**：编辑数据 → 等待3秒 → 点"保存项目" → 直接保存

### 性能测试
- [ ] 大数据量（100+模块）保存性能 < 50ms
- [ ] IndexedDB查询性能 < 10ms
- [ ] 无内存泄漏（长时间使用）

---

## 十二、总结对比

| 特性 | 之前复杂版 | 现在简化版 | 改动原因 |
|------|----------|----------|---------|
| **自动加载缓存** | ✅ 自动检测并恢复 | ❌ 不加载，只手动加载 | 避免用户困惑，符合场景1 |
| **恢复确认弹窗** | ✅ 有 | ❌ 无 | 减少干扰，用户主动操作 |
| **手动保存按钮** | ✅ 有 | ✅ 保留 | 用户主动保存正式草稿 |
| **加载草稿按钮** | ✅ 有 | ✅ 保留 | 用户主动恢复数据 |
| **配置缓存** | ✅ 缓存configData | ❌ 不缓存 | 避免配置漂移问题 |
| **debounce时间** | 2000ms | 3000ms | 减少频繁保存 |
| **关键操作保存** | ❌ 仅debounce | ✅ 立即保存 | 防止数据丢失（场景3） |
| **历史版本管理** | ✅ 复杂界面 | ✅ 简单列表 | 够用就好 |
| **数据一致性校验** | ❌ 无 | ✅ 保存时对比 | 防止数据丢失 |
| **数据清理** | 30天 | 7天（自动） | 单人使用，更激进 |
| **代码行数** | ~800行 | ~300行 | 大幅降低复杂度 |

---

**最终成果**：一个简单、可靠、无破坏性副作用的前端缓存方案，完美解决三个核心场景问题，并增加保存前的数据一致性校验作为保险。
